import React, { useState, useEffect, useRef, useMemo } from 'react';
import { fetchWithChutesFallbacks } from '../../services/chutesKeyService';
import { Spinner } from './Spinner';
import { HistoryItem } from '../../types/autostory';
import * as idb from '../../services/autostory/idb';
import { DownloadIcon } from './icons/DownloadIcon';
import { VideoIcon } from './icons/VideoIcon';
import { SparklesIcon } from './icons/SparklesIcon';
import { CloseIcon } from './icons/CloseIcon';
import { PlusIcon } from './icons/PlusIcon';
import { EditIcon } from './icons/EditIcon';
import { TrashIcon } from './icons/TrashIcon';
import { ArrowPathIcon } from './icons/ArrowPathIcon';
import { FilmIcon } from './icons/FilmIcon';
import { HistoryView } from './HistoryView';
import { ClockIcon } from './icons/ClockIcon';
import { MusicNoteIcon } from './icons/MusicNoteIcon';
import { ImageGeneratorModal } from './ImageGeneratorModal';
import { ArrowLeftIcon } from './icons/ArrowLeftIcon';
import { HomeIcon } from './icons/HomeIcon';
import { Bars3Icon } from './icons/Bars3Icon';

export type InitialAction =
  | { type: 'auto-story', imageBlob: Blob, prompts: string[], quality: '480p' | '720p', duration: '5s' | '8s' }
  | { type: 'manual-story', imageBlob: Blob, quality: '480p' | '720p', duration: '5s' | '8s' }
  | { type: 'history' };

interface ExpandVideoViewProps {
  t: (key: string, params?: { [key: string]: string | number }) => string;
  initialAction: InitialAction | null;
  onGoToMenu: () => void;
}

interface Scene {
  id: number;
  prompt: string;
  referenceImage?: { blob: Blob; url: string };
  video?: { blob: Blob; url: string };
  status: 'pending' | 'generating' | 'optimizing' | 'done' | 'error' | 'waiting_for_reference';
  error?: string;
  isEditing?: boolean;
  isAutoGenerated?: boolean;
  quality: '480p' | '720p';
  duration: '5s' | '8s';
}

type DownloadState = 'idle' | 'recording' | 'complete';
type View = 'editor' | 'history';

const PROMPT_OPTIMIZE_SYSTEM = "You are an expert prompt engineer and cinematographer for an AI video generation model. Your task is to transform the user's instruction into a powerful, detailed prompt for a 5-second video clip. Focus on: powerful action, specific camera styles and movements (cinematography), natural transitions, and strong storytelling. Use evocative, cinematic language to describe camera work (angles, movement), lighting, and mood. The resulting video must follow the reference image, including character appearance, face, and style, unless the user explicitly requests a change. Your output must be ONLY the final prompt string, ready for the video model. IMPORTANT: The content must be decent and must not contain nudity, sexually explicit content, or vulgar themes. If asked to create inappropriate content, you must politely refuse.";

const FrameSelectorModal: React.FC<{videoUrl: string, onClose: () => void, onSelect: (blob: Blob) => void, t: (key: string) => string}> = ({ videoUrl, onClose, onSelect, t }) => {
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);

    const handleSelect = () => {
        if (videoRef.current && canvasRef.current) {
            const video = videoRef.current;
            const canvas = canvasRef.current;
            video.pause();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d')?.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                if (blob) {
                    onSelect(blob);
                    onClose();
                }
            }, 'image/jpeg');
        }
    };
    
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={onClose}>
            <div className="bg-slate-800 border border-purple-500/30 rounded-xl w-full max-w-2xl" onClick={e => e.stopPropagation()}>
                <h3 className="text-base font-bold p-3 border-b border-slate-700">{t('expandVideoFrameSelectorTitle')}</h3>
                <div className="p-3 space-y-3">
                     <video 
                         ref={videoRef} 
                         src={videoUrl} 
                         className="w-full aspect-video object-contain bg-black rounded-md"
                         controls
                         playsInline
                     />
                    <p className="text-sm text-center text-slate-400">{t('expandVideoFrameSelectorInstructions')}</p>
                </div>
                <div className="p-3 border-t border-slate-700 flex justify-end gap-2">
                    <button onClick={onClose} className="bg-slate-600 hover:bg-slate-500 py-1.5 px-3 rounded-md text-sm">{t('cancel')}</button>
                    <button onClick={handleSelect} className="bg-purple-600 hover:bg-purple-700 text-white py-1.5 px-3 rounded-md text-sm">{t('expandVideoSelectFrame')}</button>
                </div>
            </div>
            <canvas ref={canvasRef} className="hidden" />
        </div>
    );
};

const ReferenceSelectorModal: React.FC<{
    scenes: Scene[],
    onClose: () => void,
    onSelectScene: (scene: Scene) => void,
    onUploadNew: () => void,
    onGenerateNew: () => void,
    t: (key: string, params?: { [key: string]: string | number }) => string
}> = ({ scenes, onClose, onSelectScene, onUploadNew, onGenerateNew, t }) => {
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={onClose}>
            <div className="bg-slate-800 border border-purple-500/30 rounded-xl w-full max-w-4xl max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                 <div className="flex justify-between items-center p-4 border-b border-slate-700">
                    <h3 className="text-lg font-bold">{t('expandVideoSelectReference')}</h3>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-slate-700"><CloseIcon className="w-5 h-5"/></button>
                 </div>
                 <div className="p-4 overflow-y-auto">
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                        <button onClick={onUploadNew} className="aspect-video w-full flex flex-col items-center justify-center bg-slate-700/50 hover:bg-slate-700/80 border-2 border-dashed border-slate-600 rounded-lg text-slate-400 transition-colors">
                            <PlusIcon className="w-8 h-8 mb-2" />
                            <span className="font-semibold">{t('expandVideoUploadNew')}</span>
                        </button>
                         <button onClick={onGenerateNew} className="aspect-video w-full flex flex-col items-center justify-center bg-slate-700/50 hover:bg-slate-700/80 border-2 border-dashed border-slate-600 rounded-lg text-slate-400 transition-colors">
                            <SparklesIcon className="w-8 h-8 mb-2" />
                            <span className="font-semibold">{t('generateWithAI')}</span>
                        </button>
                        {scenes.map((scene, index) => (
                             <button key={scene.id} onClick={() => onSelectScene(scene)} className="aspect-video w-full relative group rounded-lg overflow-hidden bg-black">
                                <video src={scene.video!.url} muted loop autoPlay playsInline className="w-full h-full object-cover transition-transform group-hover:scale-110" />
                                <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent"></div>
                                <span className="absolute bottom-2 left-2 text-white font-bold text-sm">{t('expandVideoReferenceFromScene', {count: index + 1})}</span>
                             </button>
                        ))}
                    </div>
                 </div>
            </div>
        </div>
    );
};

const extractFrame = (videoBlob: Blob, time: 'first' | 'last'): Promise<Blob> => {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(videoBlob);
        video.muted = true;
        video.preload = 'metadata';

        video.onloadedmetadata = () => {
            video.currentTime = time === 'last' ? video.duration : 0;
        };

        video.onseeked = () => {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                reject(new Error("Could not get canvas context"));
                return;
            }
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                if (blob) {
                    resolve(blob);
                } else {
                    reject(new Error("Canvas to Blob conversion failed"));
                }
                URL.revokeObjectURL(video.src);
            }, 'image/jpeg');
        };

        video.onerror = (e) => {
            reject(new Error("Video loading error"));
            URL.revokeObjectURL(video.src);
        };
    });
};


export const ExpandVideoView: React.FC<ExpandVideoViewProps> = ({ t, initialAction, onGoToMenu }) => {
    const [scenes, setScenes] = useState<Scene[]>([]);
    const [sessionId, setSessionId] = useState<number | null>(null);
    const [sessionSeed, setSessionSeed] = useState<number | null>(null);
    const [sessionQuality, setSessionQuality] = useState<'480p' | '720p'>('480p');
    const [sessionDuration, setSessionDuration] = useState<'5s' | '8s'>('8s');
    const [isOptimizing, setIsOptimizing] = useState<{ [key: number]: boolean }>({});
    const [error, setError] = useState<string | null>(null);
    const [isFrameSelectorOpen, setIsFrameSelectorOpen] = useState(false);
    const [videoForFrameSelection, setVideoForFrameSelection] = useState<string | null>(null);
    const onFrameSelectedCallback = useRef<((blob: Blob) => void) | null>(null);
    const referenceUpdateInputRef = useRef<HTMLInputElement>(null);
    const [updatingRefForSceneId, setUpdatingRefForSceneId] = useState<number | null>(null);
    const [fullscreenMedia, setFullscreenMedia] = useState<{url: string, type: 'image' | 'video'} | null>(null);
    const [isReferenceSelectorOpen, setIsReferenceSelectorOpen] = useState(false);
    const [isCombineModalOpen, setIsCombineModalOpen] = useState(false);
    const [history, setHistory] = useState<HistoryItem[]>([]);
    const [isImageGeneratorOpen, setIsImageGeneratorOpen] = useState(false);
    const [currentView, setCurrentView] = useState<View>('editor');
    const [draggedSceneId, setDraggedSceneId] = useState<number | null>(null);


    const loadHistory = async () => {
        const historyItems = await idb.getHistory();
        setHistory(historyItems);
    };

    useEffect(() => {
        loadHistory();
    }, []);
    
    const handleManualStoryStart = (initialImageBlob: Blob, quality: '480p' | '720p', duration: '5s' | '8s') => {
        if (!sessionId) {
            setSessionId(Date.now());
            setSessionSeed(Math.floor(Math.random() * 1000000));
        }
        setSessionQuality(quality);
        setSessionDuration(duration);
        const url = URL.createObjectURL(initialImageBlob);
        const newScene: Scene = { 
            id: Date.now(), 
            prompt: '', 
            referenceImage: { blob: initialImageBlob, url }, 
            status: 'pending', 
            isEditing: true,
            quality,
            duration
        };
        setScenes([newScene]);
    };

    const handleAutoStoryGenerated = (initialImageBlob: Blob, prompts: string[], quality: '480p' | '720p', duration: '5s' | '8s') => {
        const currentSessionId = Date.now();
        setSessionId(currentSessionId);
        setSessionSeed(Math.floor(Math.random() * 1_000_000));
        setSessionQuality(quality);
        setSessionDuration(duration);
        const initialImageUrl = URL.createObjectURL(initialImageBlob);
        const newScenes: Scene[] = prompts.map((prompt, index) => {
            const sceneBase = {
                id: Date.now() + index,
                prompt: prompt,
                isAutoGenerated: true,
                quality,
                duration,
            };
            if (index === 0) {
                return {
                    ...sceneBase,
                    referenceImage: { blob: initialImageBlob, url: initialImageUrl },
                    status: 'pending' as const,
                    isEditing: false,
                };
            }
            return {
                ...sceneBase,
                status: 'waiting_for_reference' as const,
                isEditing: false,
            };
        });
        setScenes(newScenes);
    };
    
    useEffect(() => {
        if (initialAction) {
            setScenes([]);
            setSessionId(null);
            setSessionSeed(null);
            setError(null);
            setCurrentView('editor');

            switch (initialAction.type) {
                case 'auto-story':
                    handleAutoStoryGenerated(initialAction.imageBlob, initialAction.prompts, initialAction.quality, initialAction.duration);
                    break;
                case 'manual-story':
                    handleManualStoryStart(initialAction.imageBlob, initialAction.quality, initialAction.duration);
                    break;
                case 'history':
                    setCurrentView('history');
                    break;
            }
        }
    }, [initialAction]);

    const handlePromptChange = (id: number, newPrompt: string) => {
        setScenes(prev => prev.map(s => s.id === id ? { ...s, prompt: newPrompt } : s));
    };

    const toggleEditPrompt = (id: number) => {
        setScenes(prev => prev.map(s => s.id === id ? { ...s, isEditing: !s.isEditing } : s));
    };

    const handleOptimizePrompt = async (sceneId: number) => {
        const scene = scenes.find(s => s.id === sceneId);
        if (!scene || !scene.prompt.trim() || isOptimizing[sceneId]) return;
        setIsOptimizing(prev => ({ ...prev, [sceneId]: true }));
        setError(null);
        try {
            const response = await fetchWithChutesFallbacks("https://llm.chutes.ai/v1/chat/completions", {
                method: "POST", headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    model: 'deepseek-ai/DeepSeek-V3-0324',
                    messages: [ { role: "system", content: PROMPT_OPTIMIZE_SYSTEM }, { role: "user", content: scene.prompt } ],
                    temperature: 0.7
                })
            });
            const data = await response.json();
            const optimizedPrompt = data.choices[0]?.message?.content?.trim();
            if (optimizedPrompt) handlePromptChange(sceneId, optimizedPrompt);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'An unknown error occurred during optimization.');
        } finally {
            setIsOptimizing(prev => ({ ...prev, [sceneId]: false }));
        }
    };
    
    const handleReferenceFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        const sceneIdToUpdate = updatingRefForSceneId;

        if (!file || !sceneIdToUpdate) {
            if (e.target) e.target.value = '';
            setUpdatingRefForSceneId(null);
            return;
        }

        const newRefUrl = URL.createObjectURL(file);
        
        setScenes(prev => {
            const sceneIndex = prev.findIndex(s => s.id === sceneIdToUpdate);
            if (sceneIndex === -1) return prev;
            
            return prev.map((s, index) => {
                if (index < sceneIndex) return s;

                if (index === sceneIndex) {
                    if (s.referenceImage) URL.revokeObjectURL(s.referenceImage.url);
                    if (s.video) URL.revokeObjectURL(s.video.url);
                    return {
                        ...s,
                        referenceImage: { blob: file, url: newRefUrl },
                        video: undefined,
                        status: 'pending' as const,
                        isEditing: true,
                    };
                }
                
                // index > sceneIndex
                if (s.referenceImage) URL.revokeObjectURL(s.referenceImage.url);
                if (s.video) URL.revokeObjectURL(s.video.url);
                return {
                    ...s,
                    referenceImage: undefined,
                    video: undefined,
                    status: 'waiting_for_reference' as const,
                    isEditing: false,
                };
            });
        });

        setUpdatingRefForSceneId(null);
        if (e.target) e.target.value = '';
    };

    const handleImageGenerated = (blob: Blob) => {
        if (!sessionId) {
            setSessionId(Date.now());
            setSessionSeed(Math.floor(Math.random() * 1000000));
        }
        const url = URL.createObjectURL(blob);
        const newScene: Scene = { 
            id: Date.now(), 
            prompt: '', 
            referenceImage: { blob: blob, url }, 
            status: 'pending', 
            isEditing: true,
            quality: sessionQuality,
            duration: sessionDuration
        };
        setScenes(prev => [...prev, newScene]);
        setIsImageGeneratorOpen(false);
    };
    
    const handleGenerateScene = async (sceneId: number) => {
        const scene = scenes.find(s => s.id === sceneId);
        if (!scene || !scene.prompt.trim() || !scene.referenceImage) return;
    
        const finalPrompt = `CRITICAL INSTRUCTION: The generated video MUST be 100% consistent with the reference image. DO NOT change the characters, their appearance, clothing, or the environment. Only animate the scene based on the following action: ${scene.prompt}. Ensure the last frame of the video shows a clear, forward-facing view of the main character's face.`;
    
        setScenes(prev => prev.map(s => s.id === sceneId ? { ...s, status: 'generating', error: undefined, isEditing: false } : s));
        
        const onRetry = (attempt: number, maxRetries: number, serverName: string) => {
            setScenes(prev => prev.map(s => 
                s.id === sceneId 
                    ? { ...s, status: 'generating', error: `Server ${serverName} sibuk. Mencoba lagi... (${attempt}/${maxRetries})` } 
                    : s
            ));
        };

        try {
            const reader = new FileReader();
            reader.readAsDataURL(scene.referenceImage.blob);
            reader.onloadend = async () => {
                try {
                    const base64data = (reader.result as string)?.split(',')[1];
                    if (!base64data) throw new Error("Could not read image data.");
    
                    const payloadOptions = {
                        resolution: scene.quality === '720p' ? '720p' : '480p',
                        fast: scene.quality !== '720p',
                        fps: scene.duration === '5s' ? 24 : 16,
                        frames: 140,
                    };

                    const response = await fetchWithChutesFallbacks("https://chutes-wan-2-2-i2v-14b-fast.chutes.ai/generate", {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            image: base64data,
                            prompt: finalPrompt,
                            ...payloadOptions,
                            seed: sessionSeed,
                            guidance_scale: 1,
                            guidance_scale_2: 1,
                            negative_prompt: "text, watermark, signature, username, blur, distortion, low quality, error, jpeg artifacts, ugly, duplicate, morbid, mutilated, out of frame, extra fingers, mutated hands, poorly drawn hands, poorly drawn face, mutation, deformed, dehydrated, bad anatomy, bad proportions, extra limbs, cloned face, disfigured, gross proportions, malformed limbs, missing arms, missing legs, extra arms, extra legs, fused fingers, too many fingers, long neck, username, watermark, signature, static, motionless, noisy, grainy"
                        })
                    }, onRetry);
    
                    const videoBlob = await response.blob();
                    const videoUrl = URL.createObjectURL(videoBlob);
                    
                    setScenes(prevScenes => {
                        const currentSceneIndex = prevScenes.findIndex(s => s.id === sceneId);
                        const nextScene = (currentSceneIndex > -1 && currentSceneIndex < prevScenes.length - 1) ? prevScenes[currentSceneIndex + 1] : null;

                        if (nextScene && nextScene.status === 'waiting_for_reference') {
                            (async () => {
                                await new Promise(resolve => setTimeout(resolve, 2000)); // Add delay
                                const lastFrameBlob = await extractFrame(videoBlob, 'last');
                                const lastFrameUrl = URL.createObjectURL(lastFrameBlob);
                                setScenes(prev => prev.map(s => {
                                    if (s.id === sceneId) return {...s, status: 'done', video: { blob: videoBlob, url: videoUrl }};
                                    if (s.id === nextScene.id) return {...s, status: 'pending', isEditing: false, referenceImage: {blob: lastFrameBlob, url: lastFrameUrl}};
                                    return s;
                                }));
                            })();
                            return prevScenes.map(s => s.id === sceneId ? { ...s, status: 'done', video: { blob: videoBlob, url: videoUrl } } : s);
                        } else {
                            return prevScenes.map(s => s.id === sceneId ? { ...s, status: 'done', video: { blob: videoBlob, url: videoUrl } } : s);
                        }
                    });
                    
                    await idb.addHistoryItem({
                        sessionId: sessionId!,
                        timestamp: Date.now(),
                        type: 'scene',
                        prompt: scene.prompt,
                        videoBlob: videoBlob,
                        referenceImageBlob: scene.referenceImage?.blob,
                    });
                    await loadHistory();

                } catch (err) {
                    setScenes(prev => prev.map(s => s.id === sceneId ? { ...s, status: 'error', error: err instanceof Error ? err.message : 'Failed to generate' } : s));
                }
            };
        } catch (err) {
             setScenes(prev => prev.map(s => s.id === sceneId ? { ...s, status: 'error', error: err instanceof Error ? err.message : 'Failed to read file' } : s));
        }
    };

    const handleDeleteScene = (sceneId: number) => {
        if (window.confirm(t('confirmDelete'))) {
            const sceneToDelete = scenes.find(s => s.id === sceneId);
            if (sceneToDelete) {
                if (sceneToDelete.referenceImage) URL.revokeObjectURL(sceneToDelete.referenceImage.url);
                if (sceneToDelete.video) URL.revokeObjectURL(sceneToDelete.video.url);
            }
            setScenes(prev => {
                const updatedScenes = prev.filter(s => s.id !== sceneId);
                if (updatedScenes.length === 0) {
                    setSessionId(null);
                    setSessionSeed(null);
                }
                return updatedScenes;
            });
        }
    };

    const handleDeleteHistorySession = async (sessionId: number) => {
        if (window.confirm(t('confirmDeleteSession'))) {
            await idb.deleteHistorySession(sessionId);
            await loadHistory();
        }
    };

    const handleBackToMenuConfirm = () => {
        if (scenes.length > 0 && !window.confirm(t('confirmStartNew'))) {
            return;
        }
        onGoToMenu();
    };

    const completedScenes = scenes.filter(s => s.status === 'done' && s.video);
    const isProcessing = scenes.some(s => ['generating', 'optimizing'].includes(s.status));

    useEffect(() => {
        if (isProcessing) {
            return;
        }

        const nextScene = scenes.find(s => s.isAutoGenerated && s.status === 'pending' && s.referenceImage);
        
        if (nextScene) {
            handleGenerateScene(nextScene.id);
        }
    }, [scenes, isProcessing]);

    const handleDragStart = (e: React.DragEvent<HTMLDivElement>, sceneId: number) => {
        setDraggedSceneId(sceneId);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
    };
    
    const handleDrop = (targetSceneId: number) => {
        if (draggedSceneId === null || draggedSceneId === targetSceneId) return;

        setScenes(prevScenes => {
            const draggedIndex = prevScenes.findIndex(s => s.id === draggedSceneId);
            const targetIndex = prevScenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedIndex === -1 || targetIndex === -1) return prevScenes;

            const newScenes = [...prevScenes];
            const [draggedItem] = newScenes.splice(draggedIndex, 1);
            newScenes.splice(targetIndex, 0, draggedItem);
            
            return newScenes;
        });
    };

    const handleDragEnd = () => {
        setDraggedSceneId(null);
    };

    const ActionButton: React.FC<{onClick: () => void, disabled?: boolean, children: React.ReactNode, title: string}> = ({ onClick, disabled, children, title }) => (
        <button onClick={onClick} disabled={disabled} title={title} className="p-1.5 text-slate-300 bg-slate-800/50 hover:bg-slate-700/60 disabled:text-slate-600 disabled:cursor-not-allowed rounded-md transition-colors">{children}</button>
    );

    const getStatusText = (status: Scene['status']) => {
        switch (status) {
            case 'generating': return t('generating');
            case 'optimizing': return t('sceneStatusOptimizing');
            case 'waiting_for_reference': return t('sceneStatusWaiting');
            default: return null;
        }
    }

    const editorView = (
        <>
            {error && <p className="mb-4 text-red-400 bg-red-900/50 p-3 rounded-lg">{error}</p>}
            <div className="flex-1 overflow-y-auto pr-2 -mr-2 space-y-8 pb-32 sm:pb-24">
                {scenes.length === 0 && !isProcessing && (
                     <div className="flex flex-col items-center justify-center text-center p-8 bg-slate-800/50 border-2 border-dashed border-slate-700 rounded-xl">
                        <h2 className="text-xl font-bold">Your Story is Empty</h2>
                        <p className="text-slate-400 mb-4">Add a new scene to get started.</p>
                     </div>
                )}

                {scenes.map((scene, index) => (
                    <div 
                        key={scene.id} 
                        className={`bg-slate-900/70 backdrop-blur-sm border border-purple-500/30 rounded-xl p-4 space-y-4 max-w-4xl mx-auto w-full transition-shadow ${draggedSceneId === scene.id ? 'shadow-lg shadow-purple-500/30' : ''}`}
                        draggable={!isProcessing}
                        onDragStart={(e) => handleDragStart(e, scene.id)}
                        onDragOver={handleDragOver}
                        onDrop={() => handleDrop(scene.id)}
                        onDragEnd={handleDragEnd}
                    >
                        <div className="flex justify-between items-center">
                            <div className="flex items-center gap-2">
                                {!isProcessing && (
                                    <div className="cursor-grab p-1" title="Drag to reorder">
                                        <Bars3Icon className="w-5 h-5 text-slate-500" />
                                    </div>
                                )}
                                <h3 className="text-lg font-bold text-purple-400">{t('expandVideoScene', { count: index + 1 })}</h3>
                            </div>
                            <div className="flex items-center gap-2">
                               {scene.status === 'done' && <ActionButton onClick={() => handleGenerateScene(scene.id)} title={t('expandVideoRecreateScene')}><ArrowPathIcon className="w-4 h-4" /></ActionButton>}
                               {!isProcessing && <ActionButton onClick={() => toggleEditPrompt(scene.id)} title={t('edit')}><EditIcon className="w-4 h-4" /></ActionButton>}
                               <ActionButton onClick={() => handleDeleteScene(scene.id)} title={t('delete')}><TrashIcon className="w-4 h-4" /></ActionButton>
                            </div>
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="relative group">
                                <div className="w-full aspect-[16/9] rounded-md bg-black overflow-hidden flex items-center justify-center">
                                    {scene.referenceImage ? (
                                        <img 
                                            src={scene.referenceImage.url} 
                                            alt={`Reference for scene ${index + 1}`} 
                                            className="max-w-full max-h-full object-contain cursor-pointer transition-transform group-hover:scale-105"
                                            onClick={() => setFullscreenMedia({ url: scene.referenceImage!.url, type: 'image' })}
                                        />
                                    ) : (
                                        <div className="flex flex-col items-center justify-center text-slate-500">
                                            <ClockIcon className="w-8 h-8 mb-2" />
                                            <span className="text-sm font-semibold">{getStatusText(scene.status)}</span>
                                        </div>
                                    )}
                                </div>
                                <span className="absolute bottom-2 left-2 bg-black/80 text-white text-xs px-2 py-1 rounded">Source</span>
                                {scene.referenceImage && !isProcessing && (
                                    <button
                                        onClick={() => {
                                            setUpdatingRefForSceneId(scene.id);
                                            referenceUpdateInputRef.current?.click();
                                        }}
                                        title="Change reference image"
                                        className="absolute top-2 right-2 bg-black/50 text-white p-1.5 rounded-full hover:bg-black/80 transition-all opacity-0 group-hover:opacity-100 disabled:opacity-50"
                                    >
                                        <ArrowPathIcon className="w-4 h-4" />
                                    </button>
                                )}
                            </div>
                            <div className="relative group">
                                <div className="w-full aspect-[16/9] rounded-md bg-black flex items-center justify-center overflow-hidden">
                                    {(scene.status === 'generating' || scene.status === 'optimizing') && (
                                        <div className="flex flex-col items-center justify-center text-slate-400">
                                            <Spinner />
                                            <p className="mt-2 text-sm">{scene.error || getStatusText(scene.status)}</p>
                                        </div>
                                    )}
                                    {scene.status === 'error' && !scene.error?.includes('Mencoba lagi') && <p className="text-red-400 text-xs p-2">{scene.error}</p>}
                                    {scene.status === 'done' && scene.video && (
                                        <video 
                                            src={scene.video.url} 
                                            muted 
                                            autoPlay 
                                            loop 
                                            playsInline 
                                            className="max-w-full max-h-full object-contain cursor-pointer transition-transform group-hover:scale-105"
                                            onClick={() => setFullscreenMedia({ url: scene.video!.url, type: 'video' })}
                                        />
                                    )}
                                </div>
                                {scene.video && (
                                     <a 
                                        href={scene.video.url} 
                                        download={`scene-${index+1}.mp4`}
                                        onClick={(e) => e.stopPropagation()}
                                        title="Download video"
                                        className="absolute top-2 right-2 bg-black/50 text-white p-1.5 rounded-full hover:bg-black/80 transition-all opacity-0 group-hover:opacity-100"
                                     >
                                        <DownloadIcon className="w-4 h-4" />
                                     </a>
                                )}
                            </div>
                        </div>

                        {(scene.isEditing || (scene.status === 'pending' && !scene.isAutoGenerated)) ? (
                             <div className="space-y-2">
                                <div className="flex justify-between items-center">
                                    <label htmlFor={`prompt-${scene.id}`} className="font-medium text-slate-300">{t('prompt')}</label>
                                    <button onClick={() => handleOptimizePrompt(scene.id)} disabled={isOptimizing[scene.id] || !scene.prompt.trim()} className="flex items-center gap-1.5 text-xs text-purple-400 hover:text-purple-300 disabled:text-slate-500">
                                        {isOptimizing[scene.id] ? <Spinner size="sm" /> : <SparklesIcon className="w-4 h-4" />} {t('imageOptimizePrompt')}
                                    </button>
                                </div>
                                <textarea id={`prompt-${scene.id}`} value={scene.prompt} onChange={e => handlePromptChange(scene.id, e.target.value)} rows={4} className="w-full bg-slate-800/50 border border-slate-600 rounded-lg p-3 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 outline-none" />
                                <div className="flex justify-end gap-2">
                                    {scene.isEditing && <button onClick={() => toggleEditPrompt(scene.id)} className="bg-slate-600 hover:bg-slate-500 py-2 px-4 rounded-lg text-sm">{t('cancel')}</button>}
                                    <button onClick={() => handleGenerateScene(scene.id)} disabled={isProcessing || !scene.prompt.trim() || scene.status === 'waiting_for_reference'} className="bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-700 disabled:bg-slate-800 disabled:text-slate-500 flex justify-center">
                                        {scene.status === 'done' ? t('expandVideoRecreateScene') : t('expandVideoGenerateScene')}
                                    </button>
                                </div>
                            </div>
                        ) : (
                             <div className="space-y-1">
                                <label className="text-sm font-medium text-slate-400">{t('prompt')}</label>
                                <p className="text-sm text-slate-300 p-3 bg-black/20 rounded-md">{scene.prompt}</p>
                            </div>
                        )}
                    </div>
                ))}
                
                <div className="max-w-4xl mx-auto w-full space-y-4">
                    {!isProcessing && (
                        <div className="text-center p-4 border-2 border-dashed border-slate-700 rounded-xl">
                            <button
                                onClick={() => setIsReferenceSelectorOpen(true)}
                                disabled={isProcessing}
                                className="bg-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-purple-700 transition-colors disabled:bg-slate-800 disabled:text-slate-500 flex items-center gap-2 mx-auto"
                            >
                                <PlusIcon className="w-5 h-5" /> {t('expandVideoAddScene')}
                            </button>
                        </div>
                    )}
                    {completedScenes.length > 1 && !isProcessing && (
                         <div className="text-center p-4 bg-slate-900/70 backdrop-blur-sm border border-purple-500/30 rounded-xl">
                            <button
                                onClick={() => setIsCombineModalOpen(true)}
                                disabled={isProcessing}
                                className="bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-slate-800 disabled:text-slate-500 flex items-center gap-2 mx-auto"
                            >
                                <FilmIcon className="w-5 h-5" /> {t('combineAndDownload')}
                            </button>
                        </div>
                    )}
                </div>
            </div>
             <input type="file" ref={referenceUpdateInputRef} className="hidden" accept="image/*" onChange={handleReferenceFileChange} />
        </>
    );

    return (
        <div className="h-full flex flex-col p-4 sm:p-6 md:p-8">
            <header className="flex-shrink-0 mb-6 flex flex-wrap justify-between items-center gap-4">
                <div>
                     {currentView === 'history' ? (
                         <button onClick={() => setCurrentView('editor')} title={t('backButton')} className="flex items-center gap-2 bg-slate-700/50 hover:bg-slate-700/80 px-4 py-2 rounded-lg transition-colors">
                            <ArrowLeftIcon className="w-5 h-5" />
                            <span className="hidden sm:inline font-semibold">{t('backButton')}</span>
                        </button>
                     ) : (
                        <button onClick={handleBackToMenuConfirm} title={t('newStory')} className="flex items-center gap-2 bg-slate-700/50 hover:bg-slate-700/80 px-4 py-2 rounded-lg transition-colors">
                            <HomeIcon className="w-5 h-5" />
                            <span className="hidden sm:inline font-semibold">{t('newStory')}</span>
                        </button>
                     )}
                </div>
                <div className="flex items-center gap-2">
                    <button onClick={() => setCurrentView('history')} title={t('historyButton')} className="flex items-center gap-2 bg-slate-700/50 hover:bg-slate-700/80 px-4 py-2 rounded-lg transition-colors">
                        <ClockIcon className="w-5 h-5" />
                        <span className="hidden sm:inline font-semibold">{t('historyButton')}</span>
                    </button>
                </div>
            </header>

            {currentView === 'editor' && editorView}
            {currentView === 'history' && (
                <div className="flex-1 overflow-y-auto">
                    <HistoryView history={history} onDeleteSession={handleDeleteHistorySession} t={t} />
                </div>
            )}
            
            {isFrameSelectorOpen && videoForFrameSelection && (
                <FrameSelectorModal 
                    videoUrl={videoForFrameSelection} 
                    onClose={() => setIsFrameSelectorOpen(false)}
                    onSelect={onFrameSelectedCallback.current!}
                    t={t}
                />
            )}
            {isReferenceSelectorOpen && (
                <ReferenceSelectorModal
                    scenes={completedScenes}
                    onClose={() => setIsReferenceSelectorOpen(false)}
                    onSelectScene={(scene) => {
                        setIsReferenceSelectorOpen(false);
                        onFrameSelectedCallback.current = (blob: Blob) => {
                            const frameUrl = URL.createObjectURL(blob);
                            const newScene: Scene = { 
                                id: Date.now(), 
                                prompt: '', 
                                referenceImage: { blob, url: frameUrl }, 
                                status: 'pending', 
                                isEditing: true,
                                quality: sessionQuality,
                                duration: sessionDuration,
                             };
                            setScenes(prev => [...prev, newScene]);
                        };
                        setVideoForFrameSelection(scene.video!.url);
                        setIsFrameSelectorOpen(true);
                    }}
                    onUploadNew={() => {
                        setIsReferenceSelectorOpen(false);
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = 'image/*,video/*';
                        input.onchange = (e) => {
                            const target = e.target as HTMLInputElement;
                            if (target.files?.[0]) {
                                const file = target.files[0];
                                if (file.type.startsWith('image/')) {
                                    const blob = file;
                                    const url = URL.createObjectURL(blob);
                                    const newScene: Scene = { id: Date.now(), prompt: '', referenceImage: { blob, url }, status: 'pending', isEditing: true, quality: sessionQuality, duration: sessionDuration };
                                    setScenes(prev => [...prev, newScene]);
                                } else if (file.type.startsWith('video/')) {
                                    const url = URL.createObjectURL(file);
                                    onFrameSelectedCallback.current = (blob: Blob) => {
                                        const frameUrl = URL.createObjectURL(blob);
                                        const newScene: Scene = { id: Date.now(), prompt: '', referenceImage: { blob, url: frameUrl }, status: 'pending', isEditing: true, quality: sessionQuality, duration: sessionDuration };
                                        setScenes(prev => [...prev, newScene]);
                                    };
                                    setVideoForFrameSelection(url);
                                    setIsFrameSelectorOpen(true);
                                }
                            }
                        };
                        input.click();
                    }}
                    onGenerateNew={() => {
                        setIsReferenceSelectorOpen(false);
                        setIsImageGeneratorOpen(true);
                    }}
                    t={t}
                />
            )}
            {fullscreenMedia && (
                <div 
                    className="fixed inset-0 bg-black/90 z-[100] flex items-center justify-center p-4 backdrop-blur-sm"
                    onClick={() => setFullscreenMedia(null)}
                >
                    {fullscreenMedia.type === 'image' ? (
                        <img src={fullscreenMedia.url} alt="Fullscreen Preview" className="max-w-full max-h-full object-contain shadow-2xl rounded-lg" onClick={(e) => e.stopPropagation()} />
                    ) : (
                        <video src={fullscreenMedia.url} controls autoPlay loop className="max-w-full max-h-full object-contain shadow-2xl rounded-lg" onClick={(e) => e.stopPropagation()} />
                    )}
                     <button 
                        onClick={() => setFullscreenMedia(null)}
                        className="absolute top-4 right-4 w-10 h-10 flex items-center justify-center bg-red-600 hover:bg-red-700 text-white rounded-full transition-all transform hover:scale-110 shadow-lg"
                        aria-label="Close preview"
                      >
                        <CloseIcon className="w-6 h-6" />
                    </button>
                </div>
            )}
            {isCombineModalOpen && (
                <CombineModal 
                    scenes={completedScenes} 
                    onClose={() => setIsCombineModalOpen(false)} 
                    t={t}
                    onCombined={async (videoBlob) => {
                        if (sessionId) {
                            await idb.addHistoryItem({
                                sessionId: sessionId,
                                timestamp: Date.now(),
                                type: 'story',
                                prompt: 'Combined Story',
                                videoBlob: videoBlob,
                            });
                            await loadHistory();
                        }
                    }}
                />
            )}
             {isImageGeneratorOpen && (
                <ImageGeneratorModal
                    onClose={() => setIsImageGeneratorOpen(false)}
                    onSelect={handleImageGenerated}
                    t={t}
                />
            )}
        </div>
    );
};

const CombineModal: React.FC<{ scenes: Scene[], onClose: () => void, t: (key: string, params?: { [key: string]: string | number }) => string, onCombined: (blob: Blob) => void }> = ({ scenes, onClose, t, onCombined }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const previewVideoRef = useRef<HTMLVideoElement>(null);
    const audioInputRef = useRef<HTMLInputElement>(null);
    const animationFrameId = useRef<number | null>(null);
    const recorderRef = useRef<MediaRecorder | null>(null);
    const [downloadState, setDownloadState] = useState<DownloadState>('idle');
    const [downloadUrl, setDownloadUrl] = useState<string | null>(null);
    const [downloadProgress, setDownloadProgress] = useState(0);
    const [backgroundMusic, setBackgroundMusic] = useState<{file: File, url: string} | null>(null);
    const [musicVolume, setMusicVolume] = useState(0.5);

    const videoUrls = useMemo(() => scenes.map(s => s.video!.url), [scenes]);

    useEffect(() => {
        const video = previewVideoRef.current;
        const canvas = canvasRef.current;
        if (!video || !canvas || videoUrls.length === 0) return;

        let currentVideoIndex = 0;

        const playNextVideo = () => {
            currentVideoIndex = (currentVideoIndex + 1) % videoUrls.length;
            video.src = videoUrls[currentVideoIndex];
            video.play().catch(console.error);
        };

        const renderLoop = () => {
            if (canvas && video) {
                const ctx = canvas.getContext('2d');
                ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);
            }
            animationFrameId.current = requestAnimationFrame(renderLoop);
        };

        video.addEventListener('ended', playNextVideo);
        video.onloadedmetadata = () => {
            if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
        };

        video.src = videoUrls[0];
        video.play().catch(console.error);
        renderLoop();

        return () => {
            video.removeEventListener('ended', playNextVideo);
            if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
        };
    }, [videoUrls]);

    const handleMusicFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && file.type.startsWith('audio/')) {
            if (backgroundMusic) URL.revokeObjectURL(backgroundMusic.url);
            setBackgroundMusic({ file, url: URL.createObjectURL(file)});
        }
        e.target.value = '';
    }

    const handleStartCombination = async () => {
        if (scenes.length === 0) return;
        setDownloadState('recording');
        setDownloadProgress(0);
        
        const canvas = document.createElement('canvas');
        const firstVideo = document.createElement('video');
        firstVideo.src = URL.createObjectURL(scenes[0].video!.blob);
        await new Promise<void>(res => firstVideo.onloadedmetadata = () => res());
        canvas.width = firstVideo.videoWidth;
        canvas.height = firstVideo.videoHeight;
        URL.revokeObjectURL(firstVideo.src);
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        const videoBlobs = scenes.map(s => s.video!.blob);
        const durations = await Promise.all(videoBlobs.map(blob =>
            new Promise<number>(resolve => {
                const tempVideo = document.createElement('video');
                tempVideo.src = URL.createObjectURL(blob);
                tempVideo.onloadedmetadata = () => {
                    URL.revokeObjectURL(tempVideo.src);
                    resolve(tempVideo.duration);
                };
            })
        ));
        const totalDuration = durations.reduce((a, b) => a + b, 0);

        const audioContext = new AudioContext();
        await audioContext.resume();
        const destNode = audioContext.createMediaStreamDestination();
        
        let musicAudioElement: HTMLAudioElement | null = null;
        if (backgroundMusic) {
            musicAudioElement = new Audio(backgroundMusic.url);
            musicAudioElement.loop = true;
            const musicSourceNode = audioContext.createMediaElementSource(musicAudioElement);
            const musicGainNode = audioContext.createGain();
            musicGainNode.gain.value = musicVolume;
            musicSourceNode.connect(musicGainNode);
            musicGainNode.connect(destNode);
        }

        const audioTrack = destNode.stream.getAudioTracks()[0];
        const canvasStream = canvas.captureStream(30);
        const videoTrack = canvasStream.getVideoTracks()[0];
        const combinedStream = new MediaStream([videoTrack, audioTrack]);

        recorderRef.current = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });
        const chunks: Blob[] = [];
        recorderRef.current.ondataavailable = (e) => chunks.push(e.data);
        recorderRef.current.onstop = () => {
            const webmBlob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(webmBlob);
            setDownloadUrl(url);
            setDownloadState('complete');
            audioContext.close();
            onCombined(webmBlob);
        };
        
        recorderRef.current.start();
        musicAudioElement?.play();
        let accumulatedTime = 0;
    
        const processVideo = async (index: number) => {
            if (index >= videoBlobs.length) {
                recorderRef.current?.stop();
                musicAudioElement?.pause();
                return;
            }

            const video = document.createElement('video');
            video.muted = true;
            const videoUrl = URL.createObjectURL(videoBlobs[index]);
            video.src = videoUrl;

            const sourceNode = audioContext.createMediaElementSource(video);
            sourceNode.connect(destNode);

            video.onended = () => {
                accumulatedTime += durations[index];
                URL.revokeObjectURL(videoUrl);
                sourceNode.disconnect();
                processVideo(index + 1);
            };

            await video.play();

            const renderFrame = () => {
                if (video.paused || video.ended) return;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (totalDuration > 0) {
                    const progress = ((accumulatedTime + video.currentTime) / totalDuration) * 100;
                    setDownloadProgress(progress);
                }
                requestAnimationFrame(renderFrame);
            };
            requestAnimationFrame(renderFrame);
        };
        
        await processVideo(0);
    };

    const handleDownloadAndConvert = () => {
        window.open('https://cloudconvert.com/webm-to-mp4', '_blank', 'noopener,noreferrer');
    };


    const resetDownload = () => {
        setDownloadState('idle');
        if (downloadUrl) URL.revokeObjectURL(downloadUrl);
        setDownloadUrl(null);
        setDownloadProgress(0);
    };

    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={onClose}>
            <div className="bg-slate-800 border border-purple-500/30 rounded-xl w-full max-w-2xl" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center p-3 border-b border-slate-700">
                    <h3 className="text-lg font-bold">{t('combineModalTitle')}</h3>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-slate-700"><CloseIcon className="w-5 h-5"/></button>
                </div>
                <div className="p-4 space-y-4">
                    <div className="mb-2">
                        <h4 className="text-sm font-semibold text-slate-300 mb-2">Scenes to combine ({scenes.length}):</h4>
                        <div className="flex space-x-2 overflow-x-auto pb-2 -mx-4 px-4">
                            {scenes.map((scene, index) => (
                                <div key={scene.id} className="flex-shrink-0 w-32 text-center">
                                    <video src={scene.video!.url} className="w-full aspect-video rounded bg-black" muted loop playsInline onMouseEnter={e => e.currentTarget.play()} onMouseLeave={e => e.currentTarget.pause()}/>
                                    <p className="text-xs mt-1 text-slate-400">{t('expandVideoScene', {count: index + 1})}</p>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="w-full aspect-video bg-black rounded-md overflow-hidden">
                        <canvas ref={canvasRef} className="w-full h-full object-contain" />
                        <video ref={previewVideoRef} playsInline muted loop className="hidden" />
                    </div>
                     <p className="text-sm text-center text-slate-400">{t('combineModalDescription')}</p>
                     
                     <div className="space-y-3 bg-slate-900/50 p-3 rounded-lg">
                        {!backgroundMusic ? (
                            <button onClick={() => audioInputRef.current?.click()} className="w-full flex items-center justify-center gap-2 bg-slate-700 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg">
                                <MusicNoteIcon className="w-5 h-5" />
                                {t('addBackgroundMusic')}
                            </button>
                        ) : (
                            <div className="space-y-2">
                                <div className="flex justify-between items-center text-sm">
                                    <p className="text-slate-300 truncate pr-2">{backgroundMusic.file.name}</p>
                                    <button onClick={() => setBackgroundMusic(null)} className="text-red-400 hover:text-red-300 text-xs font-bold">{t('removeMusic')}</button>
                                </div>
                                <div className="flex items-center gap-3">
                                    <label htmlFor="volume" className="text-sm text-slate-400 whitespace-nowrap">{t('backgroundMusicVolume')}</label>
                                    <input
                                        id="volume"
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.01"
                                        value={musicVolume}
                                        onChange={(e) => setMusicVolume(parseFloat(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"
                                    />
                                </div>
                            </div>
                        )}
                        <input type="file" ref={audioInputRef} accept="audio/*" className="hidden" onChange={handleMusicFileChange} />
                     </div>

                    
                    {downloadState === 'idle' && (
                        <button onClick={handleStartCombination} className="w-full bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-cyan-700 flex justify-center items-center gap-2">
                             {t('combineModalStart')}
                        </button>
                    )}
                    {downloadState === 'recording' && (
                        <div className="space-y-2">
                            <p className="text-center font-medium text-purple-400">{t('combineModalRecording')}</p>
                            <div className="w-full bg-slate-700 rounded-full h-2.5">
                                <div className="bg-cyan-500 h-2.5 rounded-full" style={{ width: `${downloadProgress}%` }}></div>
                            </div>
                            <p className="text-center text-sm font-bold">{Math.round(downloadProgress)}%</p>
                        </div>
                    )}
                     {downloadState === 'complete' && (
                        <div className="flex flex-col gap-2">
                            <a 
                                href={downloadUrl!} 
                                download={`video-story-${Date.now()}.webm`}
                                onClick={handleDownloadAndConvert}
                                className="w-full text-center bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-cyan-700"
                            >
                                {t('combineModalDownload')}
                            </a>
                            <button onClick={resetDownload} className="w-full bg-slate-600 hover:bg-slate-500 py-3 px-4 rounded-lg">{t('combineModalAgain')}</button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};